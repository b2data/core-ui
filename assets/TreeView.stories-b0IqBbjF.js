import{j as e,r as I}from"./iframe-Bt0NHjzt.js";import{r as ie}from"./index-Ypw_AV9V.js";import{j as T,k as Y,l as Q,m as ae,n as se,o as ee,u as le,p as de}from"./ListNumberedIcon-BnyCaxUM.js";import{c as E}from"./createSvgIcon-BmHbKF__.js";import{B as C}from"./Box-CDPnqyyJ.js";import{S as j}from"./Stack-DlVwxrP6.js";import{T as d}from"./Typography-C-487Qlx.js";import{C as z}from"./Chip-B4MlGWYj.js";import{L as O}from"./MenuList-Bt7l0Gye.js";import{B as b}from"./Button-C5akElcv.js";import{P as G}from"./Paper-DKuqXmbM.js";import{a as ne}from"./Avatar-IrxP2okY.js";import{L as ce}from"./ListItem-CQncx4D-.js";import{a as me}from"./ListItemText-B-C50eDN.js";import"./preload-helper-PPVm8Dsz.js";import"./index-gtplWchC.js";import"./Alert-XYhqTMiI.js";import"./memoTheme-BgU4zM9I.js";import"./styled-BEaRT_Fa.js";import"./useSlot-B6QK4qS-.js";import"./mergeSlotProps-CTGzhqDY.js";import"./isHostComponent-DVu5iVWx.js";import"./useForkRef-hJSLhPXd.js";import"./createSimplePaletteValueFilter-bm0fmN_7.js";import"./generateUtilityClasses-DDbjFgb8.js";import"./generateUtilityClass-BtcU_pBl.js";import"./Close-BzuDRxKm.js";import"./IconButton-CNheUIxq.js";import"./ButtonBase-CyUYjTfn.js";import"./useTimeout-KoRalZn8.js";import"./TransitionGroupContext-B0SjSjGE.js";import"./useEventCallback-DRFCyGqk.js";import"./isFocusVisible-B8k4qzLc.js";import"./CircularProgress-CmZKsxNW.js";import"./Autocomplete-DfOloYj6.js";import"./Typography-D0JS2iMU.js";import"./ListItem-D_IbDIhi.js";import"./ListSubheader-BU1wollj.js";import"./IconButton-D5Gh2CxO.js";import"./ListItemAvatar-TDjQNRAM.js";import"./ListContext-CbahI33F.js";import"./ListItemButton-DhLBmSRW.js";import"./listItemButtonClasses-CXNhffuE.js";import"./MenuItem-CjbaUP4J.js";import"./listItemTextClasses-CiRxluPw.js";import"./Menu-DxqQmRlO.js";import"./Menu-sG-3ifRZ.js";import"./useSlotProps-BJcXo2-m.js";import"./Popover-B6iscEM3.js";import"./ownerDocument-DW-IO8s5.js";import"./ownerWindow-HkKU3E4x.js";import"./debounce-Be36O1Ab.js";import"./Grow-B4ACijKG.js";import"./useTheme-CJIytwIy.js";import"./utils-ByOi0em4.js";import"./getReactElementRef-CjonG1mU.js";import"./mergeSlotProps-CoXSsvkz.js";import"./Modal-DoKZQW4X.js";import"./getScrollbarSize-CaCM53D3.js";import"./createChainedFunction-BO_9K8Jh.js";import"./Portal-DwdRdUOR.js";import"./Backdrop-D0NTvvjC.js";import"./MenuItem-CgK0E1tI.js";import"./Paper-BA0ib2RZ.js";import"./TextField-lt9rifhp.js";import"./TextField-XlNCdd5p.js";import"./useFormControl-CrJJaZ8v.js";import"./InputBase-Bv7eM5nS.js";import"./FormHelperText-UcvY9Cmh.js";import"./useControlled-CipIMeEA.js";import"./isMuiElement-mcr7aDks.js";import"./CircularProgress-Ca20BDYH.js";import"./Popper-CWeedMjN.js";import"./AvatarGroup-LAa3K5-K.js";import"./Backdrop-DOnkI2MV.js";import"./index-v6WlWadz.js";import"./index-D722bcqC.js";import"./KeyboardArrowRight-CacwA6J6.js";import"./styled-B9ZnSLBp.js";import"./FormControlLabel-ClMYsB8J.js";import"./Checkbox-B5IAUQr-.js";import"./LinearProgress-D7kdmpWb.js";import"./Tooltip-C2Ih7DGb.js";import"./Skeleton-BrODE6tX.js";import"./Switch-pBIYCnB9.js";import"./ClickAwayListener-BFTi1fF_.js";import"./getThemeProps-BYWuq7AA.js";import"./Button-BOIAoTHC.js";import"./Link-Btg-nJUc.js";import"./Checkbox-BDk9Dh_X.js";import"./Divider-GnQJ-qEb.js";import"./ClickAwayListener-CGXoOppE.js";import"./Collapse-DgsoXwjW.js";import"./Collapse-DZY430ZD.js";import"./ConfirmationDialog-naTDkXPm.js";import"./Dialog-CGx-l4Jz.js";import"./DialogActions-BjQjV8F6.js";import"./DialogActions-CTDUCIQQ.js";import"./DialogContent-C5W1g4e5.js";import"./DialogContent-DkieYbwR.js";import"./dialogTitleClasses-Df1yqyCK.js";import"./DialogTitle-Cw9FmisA.js";import"./DialogContext-CGwQnJxu.js";import"./Dialog-C2ZVi1oX.js";import"./DataBlock-Br7-LhAK.js";import"./DropZone-BqC_XfHs.js";import"./Popover-DQjXG3Cp.js";import"./DatePicker-BG65m1HK.js";import"./useThemeProps-Dw2wwzCj.js";import"./visuallyHidden-Dan1xhjv.js";import"./Tab-BuhvfUgS.js";import"./FormHelperText-c-PmPdFk.js";import"./DateTimePicker-pi4wL96V.js";import"./Drawer-CQw0KUL-.js";import"./FormControlLabel-B0u_L4pT.js";import"./InputBase-2-Gk462K.js";import"./LinearProgress-DroHHLmw.js";import"./MarkdownContent-ClhS6_3B.js";import"./MarkdownField-C5rNr-Mh.js";import"./MenuList-Q36aJr5B.js";import"./Popper-BItm2AEx.js";import"./Portal-D6nLhHtV.js";import"./ProgressStatistic-D6djOj9-.js";import"./Radio-C9znsdAf.js";import"./RadioGroup-D4esTSvq.js";import"./Skeleton-DhboPfu-.js";import"./SkeletonGroup-BOnh9hOr.js";import"./Slider-peTPJgly.js";import"./SnackbarProvider-BNmj47j3.js";import"./SnackbarMessage-CvFypDRU.js";import"./Stepper-CA2mOnJd.js";import"./Switch-BDqmGQTe.js";import"./Tab-B4rfpFyf.js";import"./TimePicker-sW7g8pow.js";const te=E(e.jsx("path",{d:"M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM19 4h-3.5l-1-1h-5l-1 1H5v2h14z"})),D=E(e.jsx("path",{d:"M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8zm2 16H8v-2h8zm0-4H8v-2h8zm-3-5V3.5L18.5 9z"})),pe=E(e.jsx("path",{d:"M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75z"})),v=E(e.jsx("path",{d:"M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8z"})),X=E(e.jsx("path",{d:"M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2m0 12H4V8h16z"})),re=E(e.jsx("path",{d:"M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4m0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4"})),Ut={title:"Components/TreeView",component:T,tags:["autodocs"]},_=[{id:"1",parentId:null,childrenCount:2},{id:"2",parentId:null,childrenCount:1},{id:"3",parentId:null,childrenCount:0},{id:"1-1",parentId:"1",childrenCount:2},{id:"1-2",parentId:"1",childrenCount:0},{id:"1-1-1",parentId:"1-1",childrenCount:0},{id:"1-1-2",parentId:"1-1",childrenCount:0},{id:"2-1",parentId:"2",childrenCount:0}],V=()=>e.jsx(C,{sx:{width:400,p:2},children:e.jsxs(j,{spacing:2,children:[e.jsx(d,{variant:"h6",children:"TreeView"}),e.jsx(T,{items:_,getItemLabel:t=>`Item ${t.id}`,getItemIcon:t=>t.childrenCount>0?e.jsx(v,{fontSize:"small"}):e.jsx(D,{fontSize:"small"}),onItemClick:t=>{console.log("Clicked:",t)}})]})}),L=()=>e.jsx(C,{sx:{width:400,p:2},children:e.jsxs(j,{spacing:2,children:[e.jsx(d,{variant:"h6",children:"TreeView with Actions"}),e.jsx(d,{variant:"caption",color:"text.secondary",children:"Hover over items to see action menu (three dots icon)"}),e.jsx(T,{items:_,getItemLabel:t=>`Item ${t.id}`,getItemIcon:t=>t.childrenCount>0?e.jsx(v,{fontSize:"small"}):e.jsx(D,{fontSize:"small"}),getItemActions:t=>[{label:"Edit",icon:e.jsx(pe,{fontSize:"small"}),withDivider:!0,onClick:()=>{console.log("Edit:",t)}},{label:"Delete",sx:{color:"error.main"},icon:e.jsx(te,{fontSize:"small"}),onClick:()=>{console.log("Delete:",t)}}],onItemClick:t=>{console.log("Clicked:",t)}})]})}),R=()=>{const[t,c]=I.useState(null);return e.jsx(C,{sx:{width:400,p:2},children:e.jsxs(j,{spacing:2,children:[e.jsx(d,{variant:"h6",children:"TreeView with Selection"}),e.jsxs(C,{sx:{height:"40px"},children:[e.jsxs(d,{variant:"caption",color:"text.secondary",children:["Selected:"," "]}),t?e.jsx(z,{label:t,size:"small"}):e.jsx(d,{variant:"caption",color:"text.secondary",children:"None"})]}),e.jsx(C,{}),e.jsx(T,{items:_,getItemLabel:a=>`Item ${a.id}`,getItemIcon:a=>a.childrenCount>0?e.jsx(v,{fontSize:"small"}):e.jsx(D,{fontSize:"small"}),selectedItemId:t??void 0,onSelectedItemChange:a=>{c(a),console.log("Selected:",a)},onItemClick:a=>{console.log("Clicked:",a)}})]})})},A=()=>{const[t,c]=I.useState([{id:"1",parentId:null,childrenCount:2},{id:"2",parentId:null,childrenCount:1},{id:"3",parentId:null,childrenCount:0},{id:"1-1",parentId:"1",childrenCount:2},{id:"1-2",parentId:"1",childrenCount:0},{id:"1-1-1",parentId:"1-1",childrenCount:0},{id:"1-1-2",parentId:"1-1",childrenCount:0},{id:"2-1",parentId:"2",childrenCount:0}]);return e.jsx(C,{sx:{width:400,p:2},children:e.jsxs(j,{spacing:2,children:[e.jsx(d,{variant:"h6",children:"TreeView with Drag & Drop"}),e.jsx(d,{variant:"caption",color:"text.secondary",children:'Drag items to reorder or move them into other items. Item "3" cannot be dragged, and items cannot be moved inside item "2".'}),e.jsx(T,{items:t,enableDragAndDrop:!0,getItemLabel:a=>`Item ${a.id}`,getItemIcon:a=>a.childrenCount>0?e.jsx(v,{fontSize:"small"}):e.jsx(D,{fontSize:"small"}),canDragItem:a=>a.id!=="3",canDropOnItem:(a,i,l)=>!(i?.id==="2"&&l==="inside"),onItemsReorder:({draggedItemId:a,targetItemId:i,position:l,newItems:s})=>{console.log("Reorder:",{draggedItemId:a,targetItemId:i,position:l}),c(s)},onItemClick:a=>{console.log("Clicked:",a)}})]})})},B=()=>{const[t,c]=I.useState([{id:"1",parentId:null,childrenCount:2,name:"Folder 1"},{id:"2",parentId:null,childrenCount:1,name:"Folder 2"},{id:"3",parentId:null,childrenCount:0,name:"Folder 3"},{id:"1-1",parentId:"1",childrenCount:0,name:"Subfolder 1-1"},{id:"1-2",parentId:"1",childrenCount:0,name:"Subfolder 1-2"},{id:"2-1",parentId:"2",childrenCount:0,name:"Subfolder 2-1"}]),a=I.useCallback(i=>{const l=t.find(o=>o.id===i);if(!l)return;const s=t.map(o=>o.id===i?{...o,parentId:null}:o);c(s),alert(`Moved "${l.name||l.id}" to root`)},[t]);return e.jsx(C,{sx:{width:500,p:2},children:e.jsxs(j,{spacing:2,children:[e.jsx(d,{variant:"h6",children:"TreeView with Drag & Drop to Header"}),e.jsx(d,{variant:"caption",color:"text.secondary",children:"Drag folders from the tree and drop them into the header to move them to root level."}),e.jsxs(O,{children:[e.jsx(Y,{icon:e.jsx(v,{}),title:"Root Folder",dropId:"root",enableTreeItemDrops:!0,onTreeItemDrop:a,collapseButton:{isExpanded:!0,onToggle:()=>{}}}),e.jsx(T,{items:t,rootOffset:1,enableDragAndDrop:!0,getItemLabel:i=>i.name||`Item ${i.id}`,getItemIcon:i=>i.childrenCount>0?e.jsx(v,{fontSize:"small"}):e.jsx(X,{fontSize:"small"}),onItemsReorder:({draggedItemId:i,targetItemId:l,position:s,newItems:o})=>{console.log("Reorder:",{draggedItemId:i,targetItemId:l,position:s}),c(o)},onItemClick:i=>{console.log("Clicked:",i)}})]})]})})},Z=[{id:"user-1",name:"John Doe",email:"john@example.com"},{id:"user-2",name:"Jane Smith",email:"jane@example.com"},{id:"user-3",name:"Bob Johnson",email:"bob@example.com"},{id:"user-4",name:"Alice Williams",email:"alice@example.com"}],he=({user:t})=>{const{attributes:c,listeners:a,setNodeRef:i,isDragging:l}=de({id:t.id,data:{type:"Users",data:[t]}});return e.jsxs(ce,{ref:i,sx:{border:"1px solid",borderColor:"divider",borderRadius:1,mb:1,bgcolor:"background.paper",cursor:l?"grabbing":"grab",opacity:l?.3:1,pointerEvents:l?"none":"auto"},children:[e.jsx(ee,{sx:{mr:1,color:"text.secondary",cursor:"grab"},...c,...a}),e.jsx(ne,{sx:{width:32,height:32,mr:1,bgcolor:"primary.main"},children:e.jsx(re,{fontSize:"small"})}),e.jsx(me,{primary:t.name,secondary:t.email})]})},P=()=>{const t="treeview-expanded-items-lazy",c=[{id:"1",parentId:null,childrenCount:2},{id:"2",parentId:null,childrenCount:1},{id:"3",parentId:null,childrenCount:0},{id:"1-1",parentId:"1",childrenCount:2},{id:"1-2",parentId:"1",childrenCount:0},{id:"1-1-1",parentId:"1-1",childrenCount:0},{id:"1-1-2",parentId:"1-1",childrenCount:0},{id:"2-1",parentId:"2",childrenCount:0},{id:"4",parentId:null,childrenCount:1},{id:"4-1",parentId:"4",childrenCount:0}],a=()=>{try{const n=localStorage.getItem(t);if(n)return JSON.parse(n)}catch(n){console.error("Failed to load from localStorage:",n)}return["1","1-1"]},[i,l]=I.useState(a),s=n=>{l(n);try{localStorage.setItem(t,JSON.stringify(n)),console.log("Saved to localStorage:",n)}catch(m){console.error("Failed to save to localStorage:",m)}},o=async n=>{await new Promise(p=>setTimeout(p,500));const m=[];return n.forEach(p=>{const f=c.filter(S=>S.parentId===p);m.push(...f)}),n.forEach(p=>{if(p!==null){const f=c.find(S=>S.id===p);f&&!m.find(S=>S.id===f.id)&&m.push(f)}}),console.log("API Request - parentIds:",n),console.log("API Response - items:",m),m};return e.jsx(C,{sx:{width:400,p:2},children:e.jsxs(j,{spacing:2,children:[e.jsx(d,{variant:"h6",children:"TreeView - Controlled Mode with Lazy Loading"}),e.jsx(d,{variant:"caption",color:"text.secondary",children:"Combines controlled expanded state with lazy loading. Expanded state is persisted to localStorage and restored on page reload."}),e.jsxs(C,{children:[e.jsxs(d,{variant:"caption",color:"text.secondary",children:["Currently expanded:"," "]}),i.length>0?e.jsx(C,{sx:{display:"flex",gap:.5,flexWrap:"wrap",mt:.5},children:i.map(n=>e.jsx(z,{label:n,size:"small"},n))}):e.jsx(d,{variant:"caption",color:"text.secondary",children:"None"})]}),e.jsx(T,{dataSource:{fetchItems:o,onItemsLoaded:n=>{console.log("Items loaded:",n)},onLoadError:(n,m)=>{console.error("Load error:",n,"for parentIds:",m)}},expandedItemIds:i,onExpandedItemsChange:s,getItemLabel:n=>`Item ${n.id}`,getItemIcon:n=>n.childrenCount>0?e.jsx(v,{fontSize:"small"}):e.jsx(D,{fontSize:"small"}),onItemClick:n=>{console.log("Clicked:",n)}})]})})},$=()=>{const[t,c]=I.useState(!1),a=[],i=[{id:"1",parentId:null,childrenCount:2},{id:"2",parentId:null,childrenCount:1},{id:"1-1",parentId:"1",childrenCount:0},{id:"1-2",parentId:"1",childrenCount:0},{id:"2-1",parentId:"2",childrenCount:0}],l=e.jsxs(C,{sx:{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",py:4,px:2,textAlign:"center"},children:[e.jsx(X,{sx:{fontSize:48,color:"text.secondary",mb:2,opacity:.5}}),e.jsx(d,{variant:"h6",color:"text.secondary",gutterBottom:!0,children:"No items found"}),e.jsx(d,{variant:"body2",color:"text.secondary",children:"The tree view is empty. Add items to get started."})]});return e.jsx(C,{sx:{width:400,p:2},children:e.jsxs(j,{spacing:2,children:[e.jsx(d,{variant:"h6",children:"TreeView with Empty State"}),e.jsx(d,{variant:"caption",color:"text.secondary",children:"This example demonstrates the emptyState prop. Toggle the button below to show/hide items."}),e.jsx(C,{children:e.jsx(z,{label:t?"Hide Items":"Show Items",onClick:()=>c(!t),clickable:!0,color:t?"primary":"default"})}),e.jsx(T,{items:t?i:a,emptyState:l,getItemLabel:s=>`Item ${s.id}`,getItemIcon:s=>s.childrenCount>0?e.jsx(v,{fontSize:"small"}):e.jsx(D,{fontSize:"small"}),onItemClick:s=>{console.log("Clicked:",s)}})]})})},F=()=>{const[t,c]=I.useState(0),a=[{id:"1",parentId:null,childrenCount:2},{id:"2",parentId:null,childrenCount:1},{id:"3",parentId:null,childrenCount:0},{id:"1-1",parentId:"1",childrenCount:2},{id:"1-2",parentId:"1",childrenCount:0},{id:"1-1-1",parentId:"1-1",childrenCount:0},{id:"1-1-2",parentId:"1-1",childrenCount:0},{id:"2-1",parentId:"2",childrenCount:0},{id:"4",parentId:null,childrenCount:1},{id:"4-1",parentId:"4",childrenCount:0}],i=async s=>{await new Promise(n=>setTimeout(n,1500));const o=[];return s.forEach(n=>{const m=a.filter(p=>p.parentId===n);o.push(...m)}),s.forEach(n=>{if(n!==null){const m=a.find(p=>p.id===n);m&&!o.find(p=>p.id===m.id)&&o.push(m)}}),console.log("API Request - parentIds:",s),console.log("API Response - items:",o),o},l=()=>{c(s=>s+1)};return e.jsx(C,{sx:{width:400,p:2},children:e.jsxs(j,{spacing:2,children:[e.jsx(d,{variant:"h6",children:"TreeView with Loader Demo"}),e.jsx(d,{variant:"caption",color:"text.secondary",children:'Click the "Reload" button to see the skeleton loader during initial loading.'}),e.jsx(C,{children:e.jsx(b,{variant:"contained",onClick:l,children:"Reload"})}),e.jsx(T,{dataSource:{fetchItems:i,onItemsLoaded:s=>{console.log("Items loaded:",s)},onLoadError:(s,o)=>{console.error("Load error:",s,"for parentIds:",o)}},getItemLabel:s=>`Item ${s.id}`,getItemIcon:s=>s.childrenCount>0?e.jsx(v,{fontSize:"small"}):e.jsx(D,{fontSize:"small"}),onItemClick:s=>{console.log("Clicked:",s)}},t)]})})},H=()=>{const t=I.useRef(null),[c,a]=I.useState(["1"]),[i,l]=I.useState(new Set),[s,o]=I.useState([]),[n,m]=I.useState(100),[p,f]=I.useState(null),S=[{id:"1",parentId:null,childrenCount:2},{id:"2",parentId:null,childrenCount:1},{id:"3",parentId:null,childrenCount:0},{id:"1-1",parentId:"1",childrenCount:2},{id:"1-2",parentId:"1",childrenCount:0},{id:"1-1-1",parentId:"1-1",childrenCount:0},{id:"1-1-2",parentId:"1-1",childrenCount:0},{id:"2-1",parentId:"2",childrenCount:0}],k=I.useMemo(()=>{const r=i,g=[...S.filter(x=>{if(r.has(x.id))return!1;let y=x.parentId;for(;y!==null;){if(r.has(y))return!1;y=S.find(oe=>oe.id===y)?.parentId??null}return!0}),...s];return g.map(x=>{const y=g.filter(w=>w.parentId===x.id).length;return{...x,childrenCount:y}})},[i,s]),J=I.useCallback(async r=>{await new Promise(x=>setTimeout(x,500));const u=[],g=new Set;return r.forEach(x=>{k.filter(w=>w.parentId===x).forEach(w=>{g.has(w.id)||(u.push(w),g.add(w.id))})}),r.forEach(x=>{if(x!==null){const y=k.find(w=>w.id===x);y&&!g.has(y.id)&&(u.push(y),g.add(y.id))}else k.filter(w=>w.parentId===null).forEach(w=>{g.has(w.id)||(u.push(w),g.add(w.id))})}),console.log("API Request - parentIds:",r),console.log("API Response - items:",u),u},[k]);I.useEffect(()=>{if(p){const r=setTimeout(()=>{t.current?.refresh(p.parentIds),f(null)},0);return()=>clearTimeout(r)}},[p,i]);const K=()=>{console.log("Refreshing all expanded items"),t.current?.refresh()},q=()=>{console.log("Refreshing root level"),t.current?.refresh([null])},h=()=>{console.log("Refreshing item '1' and its children"),t.current?.refresh(["1"])};return e.jsx(C,{sx:{width:400,p:2},children:e.jsxs(j,{spacing:2,children:[e.jsx(d,{variant:"h6",children:"TreeView with Refresh API"}),e.jsx(d,{variant:"caption",color:"text.secondary",children:"This example demonstrates the refresh functionality. After performing operations like create, update, or delete, you can refresh specific branches or all expanded items."}),e.jsxs(C,{sx:{display:"flex",gap:1,flexWrap:"wrap"},children:[e.jsx(b,{variant:"outlined",size:"small",onClick:K,children:"Refresh All Expanded"}),e.jsx(b,{variant:"outlined",size:"small",onClick:q,children:"Refresh Root"}),e.jsx(b,{variant:"outlined",size:"small",onClick:h,children:'Refresh Item "1"'}),e.jsx(b,{variant:"outlined",size:"small",color:"success",onClick:()=>{const r=`new-root-${n}`;console.log("Simulated create root item:",r);const u={id:r,parentId:null,childrenCount:0};o(g=>[...g,u]),m(g=>g+1),f({parentIds:[null]})},children:"Create Root Item"})]}),e.jsxs(C,{children:[e.jsxs(d,{variant:"caption",color:"text.secondary",children:["Currently expanded:"," "]}),c.length>0?e.jsx(C,{sx:{display:"flex",gap:.5,flexWrap:"wrap",mt:.5},children:c.map(r=>e.jsx(z,{label:r,size:"small"},r))}):e.jsx(d,{variant:"caption",color:"text.secondary",children:"None"})]}),e.jsx(T,{ref:t,dataSource:{fetchItems:J,onItemsLoaded:r=>{console.log("Items loaded:",r)},onLoadError:(r,u)=>{console.error("Load error:",r,"for parentIds:",u)}},expandedItemIds:c,onExpandedItemsChange:a,getItemLabel:r=>`Item ${r.id}`,getItemIcon:r=>r.childrenCount>0?e.jsx(v,{fontSize:"small"}):e.jsx(D,{fontSize:"small"}),getItemActions:r=>[{label:"Create child",icon:e.jsx(Q,{fontSize:"small"}),onClick:()=>{const u=`new-${n}`;console.log("Simulated create of:",u,"under parent:",r.id);const g={id:u,parentId:r.id,childrenCount:0};o(y=>[...y,g]),m(y=>y+1),c.includes(r.id)||a(y=>[...y,r.id]);const x=[r.id];f({parentIds:x})}},{label:"Delete (simulated)",icon:e.jsx(te,{fontSize:"small"}),sx:{color:"error.main"},onClick:()=>{console.log("Simulated delete of:",r.id);const u=r.parentId!==null?[r.parentId]:[null];o(g=>g.filter(x=>x.id!==r.id)),l(g=>{const x=new Set(g);return x.add(r.id),x}),f({parentIds:u})}}],onItemClick:r=>{console.log("Clicked:",r)}})]})})},W=()=>{const[t,c]=I.useState(!1),[a,i]=I.useState(0),l=[{id:"1",parentId:null,childrenCount:2},{id:"2",parentId:null,childrenCount:1},{id:"3",parentId:null,childrenCount:0},{id:"1-1",parentId:"1",childrenCount:0},{id:"1-2",parentId:"1",childrenCount:0},{id:"2-1",parentId:"2",childrenCount:0}],s=async o=>{if(await new Promise(m=>setTimeout(m,500)),t)throw i(m=>m+1),new Error("Failed to load items. Please try again.");const n=[];return o.forEach(m=>{const p=l.filter(f=>f.parentId===m);n.push(...p)}),o.forEach(m=>{if(m!==null){const p=l.find(f=>f.id===m);p&&!n.find(f=>f.id===p.id)&&n.push(p)}else l.filter(f=>f.parentId===null).forEach(f=>{n.find(S=>S.id===f.id)||n.push(f)})}),n};return e.jsx(C,{sx:{width:400,p:2},children:e.jsxs(j,{spacing:2,children:[e.jsx(d,{variant:"h6",children:"TreeView with Error Handling"}),e.jsx(d,{variant:"caption",color:"text.secondary",children:"This example demonstrates error handling in lazy loading mode. Toggle the error state to see how errors are handled."}),e.jsxs(C,{sx:{display:"flex",gap:1,alignItems:"center"},children:[e.jsx(b,{variant:t?"contained":"outlined",color:t?"error":"primary",size:"small",onClick:()=>c(!t),children:t?"Disable Errors":"Simulate Errors"}),a>0&&e.jsx(z,{label:`Errors: ${a}`,color:"error",size:"small"})]}),e.jsx(T,{dataSource:{fetchItems:s,onLoadError:(o,n)=>{console.error("Load error:",o,"for parentIds:",n)}},getItemLabel:o=>`Item ${o.id}`,getItemIcon:o=>o.childrenCount>0?e.jsx(v,{fontSize:"small"}):e.jsx(D,{fontSize:"small"}),onItemClick:o=>{console.log("Clicked:",o)}})]})})},U=()=>{const t=()=>{const i=[];for(let o=1;o<=5;o++)i.push({id:`root-${o}`,parentId:null,childrenCount:5});for(let o=1;o<=4;o++){const n=o===1?"root":`level-${o-1}`,m=`level-${o}`;for(let p=1;p<=5;p++){const f=o===1?`root-${p}`:`${n}-${p}`;for(let S=1;S<=5;S++){const k=o<4;i.push({id:`${m}-${p}-${S}`,parentId:f,childrenCount:k?5:0})}}}return i},c=I.useMemo(()=>t(),[]),a=I.useCallback(async i=>{await new Promise(s=>setTimeout(s,300));const l=[];return i.forEach(s=>{const o=c.filter(n=>n.parentId===s);l.push(...o)}),i.forEach(s=>{if(s!==null){const o=c.find(n=>n.id===s);o&&!l.find(n=>n.id===o.id)&&l.push(o)}else c.filter(n=>n.parentId===null).forEach(n=>{l.find(m=>m.id===n.id)||l.push(n)})}),l},[c]);return e.jsx(C,{sx:{width:400,p:2},children:e.jsxs(j,{spacing:2,children:[e.jsx(d,{variant:"h6",children:"TreeView with Large Dataset"}),e.jsxs(d,{variant:"caption",color:"text.secondary",children:["This example demonstrates performance with a large dataset (",c.length," items). Items are loaded lazily as you expand folders."]}),e.jsx(T,{dataSource:{fetchItems:a,debounceMs:100},getItemLabel:i=>`Item ${i.id}`,getItemIcon:i=>i.childrenCount>0?e.jsx(v,{fontSize:"small"}):e.jsx(D,{fontSize:"small"}),onItemClick:i=>{console.log("Clicked:",i)}})]})})},N=()=>{const[t,c]=I.useState(!0);return e.jsx(C,{sx:{width:400,p:2},children:e.jsxs(j,{spacing:2,children:[e.jsx(d,{variant:"h6",children:"TreeViewHeader with TreeView"}),e.jsxs(O,{children:[e.jsx(Y,{icon:e.jsx(v,{}),title:"My Folders",collapseButton:{isExpanded:t,onToggle:()=>c(!t)},action:{icon:e.jsx(Q,{}),tooltip:"Create new folder",onClick:()=>console.log("Create clicked")},onClick:()=>console.log("Header clicked")}),t&&e.jsx(T,{items:_,getItemLabel:a=>`Item ${a.id}`,getItemIcon:a=>a.childrenCount>0?e.jsx(v,{fontSize:"small"}):e.jsx(D,{fontSize:"small"}),onItemClick:a=>{console.log("Clicked:",a)},rootOffset:1})]})]})})},M=()=>{const t=[{id:"folder-1",parentId:null,childrenCount:2,name:"Team A"},{id:"folder-2",parentId:null,childrenCount:1,name:"Team B"},{id:"folder-3",parentId:null,childrenCount:0,name:"Team C"},{id:"folder-1-1",parentId:"folder-1",childrenCount:0,name:"Subteam 1"},{id:"folder-1-2",parentId:"folder-1",childrenCount:0,name:"Subteam 2"},{id:"folder-2-1",parentId:"folder-2",childrenCount:0,name:"Subteam 3"}],[c,a]=I.useState({}),[i,l]=I.useState([]),[s,o]=I.useState(null),[n,m]=I.useState(!0),p=s?Z.find(h=>h.id===s):null,f=I.useCallback((h,r,u)=>{console.log("External drop:",{type:h.type,data:h.data,targetItem:r.id,position:u});const g=String(r.id),x=h.data;a(y=>({...y,[g]:[...y[g]||[],...x]})),alert(`Dropped ${x.length} user(s) into "${r.name||r.id}"`)},[]),S=I.useCallback(h=>{const r=h.data;l(u=>[...u,...r]),alert(`Dropped ${r.length} user(s) into root header`)},[]),k=I.useCallback(h=>h==="Users",[]),J=I.useCallback(h=>{o(String(h.active.id))},[]),K=I.useCallback(()=>{o(null)},[]),q=()=>(le({onDragOver:({over:h,active:r})=>{if(!h||!r?.data?.current?.type)return;const u=String(h.id);if(u.startsWith("tree-header-")){const g=r.data.current.type;(k(g)??!0)&&console.log("Dragging over header:",u)}},onDragEnd:({over:h,active:r})=>{if(!h||!r?.data?.current?.type)return;if(String(h.id).startsWith("tree-header-")){const g=r.data.current.type,x=r.data.current.data||[];(k(g)??!0)&&S({type:g,data:Array.isArray(x)?x:[x]})}}}),null);return e.jsxs(ae,{onDragStart:J,onDragEnd:K,children:[e.jsx(q,{}),e.jsx(C,{sx:{width:"100%",p:2},children:e.jsxs(j,{spacing:3,direction:"row",sx:{height:600},children:[e.jsxs(G,{sx:{width:300,p:2,overflow:"auto",position:"relative"},children:[e.jsx(d,{variant:"h6",gutterBottom:!0,children:"Users (Drag to folders)"}),e.jsx(d,{variant:"caption",color:"text.secondary",sx:{mb:2,display:"block"},children:"Drag users from this list and drop them into the header or folders in the tree"}),e.jsx(O,{children:Z.map(h=>e.jsx(he,{user:h},h.id))})]}),e.jsxs(G,{sx:{flex:1,p:2,overflow:"auto"},children:[e.jsx(d,{variant:"h6",gutterBottom:!0,children:"Folders with Header (Drop users here)"}),e.jsx(d,{variant:"caption",color:"text.secondary",sx:{mb:2,display:"block"},children:"Drag users from the left panel and drop them into the header or folders. Items will highlight when you drag over them."}),e.jsxs(O,{children:[e.jsx(Y,{icon:e.jsx(v,{}),title:`Root Folder${i.length>0?` (${i.length} users)`:""}`,dropId:"root",enableExternalDrops:!0,canAcceptExternalDrop:k,collapseButton:{isExpanded:n,onToggle:()=>m(!n)},action:{icon:e.jsx(Q,{}),tooltip:"Create new folder",onClick:()=>console.log("Create clicked")},onClick:()=>console.log("Header clicked")}),n&&e.jsx(T,{items:t,rootOffset:1,enableExternalDrops:!0,onExternalDrop:f,canAcceptExternalDrop:k,getItemLabel:h=>{const r=h.name||`Item ${h.id}`,u=c[String(h.id)]?.length||0;return u>0?`${r} (${u} users)`:r},getItemIcon:h=>h.childrenCount>0?e.jsx(v,{fontSize:"small"}):e.jsx(X,{fontSize:"small"}),onItemClick:h=>{const r=c[String(h.id)];r&&r.length>0?(console.log(`Users in ${h.id}:`,r),alert(`Users in this folder:
${r.map(u=>`- ${u.name}`).join(`
`)}`)):console.log("Clicked:",h)}})]})]})]})}),ie.createPortal(e.jsx(se,{style:{zIndex:1500},children:p?e.jsxs(G,{sx:{width:280,p:1.5,border:"1px solid",borderColor:"divider",borderRadius:1,bgcolor:"background.paper",boxShadow:3,display:"flex",alignItems:"center"},children:[e.jsx(ee,{sx:{mr:1,color:"text.secondary"}}),e.jsx(ne,{sx:{width:32,height:32,mr:1,bgcolor:"primary.main"},children:e.jsx(re,{fontSize:"small"})}),e.jsxs(C,{children:[e.jsx(d,{variant:"body2",fontWeight:"medium",children:p.name}),e.jsx(d,{variant:"caption",color:"text.secondary",children:p.email})]})]}):null}),document.body)]})};V.parameters={...V.parameters,docs:{...V.parameters?.docs,source:{originalSource:`() => {
  return <Box sx={{
    width: 400,
    p: 2
  }}>
      <Stack spacing={2}>
        <Typography variant="h6">TreeView</Typography>
        <TreeView items={mockItems} getItemLabel={item => \`Item \${item.id}\`} getItemIcon={item => item.childrenCount > 0 ? <FolderIcon fontSize="small" /> : <DescriptionIcon fontSize="small" />} onItemClick={item => {
        console.log("Clicked:", item);
      }} />
      </Stack>
    </Box>;
}`,...V.parameters?.docs?.source}}};L.parameters={...L.parameters,docs:{...L.parameters?.docs,source:{originalSource:`() => {
  return <Box sx={{
    width: 400,
    p: 2
  }}>
      <Stack spacing={2}>
        <Typography variant="h6">TreeView with Actions</Typography>
        <Typography variant="caption" color="text.secondary">
          Hover over items to see action menu (three dots icon)
        </Typography>
        <TreeView items={mockItems} getItemLabel={item => \`Item \${item.id}\`} getItemIcon={item => item.childrenCount > 0 ? <FolderIcon fontSize="small" /> : <DescriptionIcon fontSize="small" />} getItemActions={(item): TreeViewAction[] => [{
        label: "Edit",
        icon: <EditIcon fontSize="small" />,
        withDivider: true,
        onClick: () => {
          console.log("Edit:", item);
        }
      }, {
        label: "Delete",
        sx: {
          color: "error.main"
        },
        icon: <DeleteIcon fontSize="small" />,
        onClick: () => {
          console.log("Delete:", item);
        }
      }]} onItemClick={item => {
        console.log("Clicked:", item);
      }} />
      </Stack>
    </Box>;
}`,...L.parameters?.docs?.source}}};R.parameters={...R.parameters,docs:{...R.parameters?.docs,source:{originalSource:`() => {
  const [selectedItemId, setSelectedItemId] = useState<TreeViewItemId | null>(null);
  return <Box sx={{
    width: 400,
    p: 2
  }}>
      <Stack spacing={2}>
        <Typography variant="h6">TreeView with Selection</Typography>
        <Box sx={{
        height: "40px"
      }}>
          <Typography variant="caption" color="text.secondary">
            Selected:{" "}
          </Typography>
          {selectedItemId ? <Chip label={selectedItemId} size="small" /> : <Typography variant="caption" color="text.secondary">
              None
            </Typography>}
        </Box>
        <Box></Box>
        <TreeView items={mockItems} getItemLabel={item => \`Item \${item.id}\`} getItemIcon={item => item.childrenCount > 0 ? <FolderIcon fontSize="small" /> : <DescriptionIcon fontSize="small" />} selectedItemId={selectedItemId ?? undefined} onSelectedItemChange={itemId => {
        setSelectedItemId(itemId);
        console.log("Selected:", itemId);
      }} onItemClick={item => {
        console.log("Clicked:", item);
      }} />
      </Stack>
    </Box>;
}`,...R.parameters?.docs?.source}}};A.parameters={...A.parameters,docs:{...A.parameters?.docs,source:{originalSource:`() => {
  const [items, setItems] = useState<TreeViewItem[]>([{
    id: "1",
    parentId: null,
    childrenCount: 2
  }, {
    id: "2",
    parentId: null,
    childrenCount: 1
  }, {
    id: "3",
    parentId: null,
    childrenCount: 0
  }, {
    id: "1-1",
    parentId: "1",
    childrenCount: 2
  }, {
    id: "1-2",
    parentId: "1",
    childrenCount: 0
  }, {
    id: "1-1-1",
    parentId: "1-1",
    childrenCount: 0
  }, {
    id: "1-1-2",
    parentId: "1-1",
    childrenCount: 0
  }, {
    id: "2-1",
    parentId: "2",
    childrenCount: 0
  }]);
  return <Box sx={{
    width: 400,
    p: 2
  }}>
      <Stack spacing={2}>
        <Typography variant="h6">TreeView with Drag & Drop</Typography>
        <Typography variant="caption" color="text.secondary">
          Drag items to reorder or move them into other items. Item "3" cannot
          be dragged, and items cannot be moved inside item "2".
        </Typography>
        <TreeView items={items} enableDragAndDrop={true} getItemLabel={item => \`Item \${item.id}\`} getItemIcon={item => item.childrenCount > 0 ? <FolderIcon fontSize="small" /> : <DescriptionIcon fontSize="small" />} canDragItem={item => {
        return item.id !== "3";
      }} canDropOnItem={(_draggedItem, targetItem, position) => {
        if (targetItem?.id === "2" && position === "inside") {
          return false;
        }
        return true;
      }} onItemsReorder={({
        draggedItemId,
        targetItemId,
        position,
        newItems
      }) => {
        console.log("Reorder:", {
          draggedItemId,
          targetItemId,
          position
        });
        setItems(newItems);
      }} onItemClick={item => {
        console.log("Clicked:", item);
      }} />
      </Stack>
    </Box>;
}`,...A.parameters?.docs?.source}}};B.parameters={...B.parameters,docs:{...B.parameters?.docs,source:{originalSource:`() => {
  const [items, setItems] = useState<TreeViewItem[]>([{
    id: "1",
    parentId: null,
    childrenCount: 2,
    name: "Folder 1"
  }, {
    id: "2",
    parentId: null,
    childrenCount: 1,
    name: "Folder 2"
  }, {
    id: "3",
    parentId: null,
    childrenCount: 0,
    name: "Folder 3"
  }, {
    id: "1-1",
    parentId: "1",
    childrenCount: 0,
    name: "Subfolder 1-1"
  }, {
    id: "1-2",
    parentId: "1",
    childrenCount: 0,
    name: "Subfolder 1-2"
  }, {
    id: "2-1",
    parentId: "2",
    childrenCount: 0,
    name: "Subfolder 2-1"
  }]);
  const handleTreeItemDrop = useCallback((itemId: TreeViewItemId) => {
    const item = items.find(i => i.id === itemId);
    if (!item) return;
    const newItems = items.map(i => {
      if (i.id === itemId) {
        return {
          ...i,
          parentId: null
        };
      }
      return i;
    });
    setItems(newItems);
    alert(\`Moved "\${(item as any).name || item.id}" to root\`);
  }, [items]);
  return <Box sx={{
    width: 500,
    p: 2
  }}>
      <Stack spacing={2}>
        <Typography variant="h6">
          TreeView with Drag & Drop to Header
        </Typography>
        <Typography variant="caption" color="text.secondary">
          Drag folders from the tree and drop them into the header to move them
          to root level.
        </Typography>
        <List>
          <TreeViewHeader icon={<FolderIcon />} title="Root Folder" dropId="root" enableTreeItemDrops={true} onTreeItemDrop={handleTreeItemDrop} collapseButton={{
          isExpanded: true,
          onToggle: () => {}
        }} />
          <TreeView items={items} rootOffset={1} enableDragAndDrop={true} getItemLabel={item => (item as any).name || \`Item \${item.id}\`} getItemIcon={item => item.childrenCount > 0 ? <FolderIcon fontSize="small" /> : <FolderOpenIcon fontSize="small" />} onItemsReorder={({
          draggedItemId,
          targetItemId,
          position,
          newItems
        }) => {
          console.log("Reorder:", {
            draggedItemId,
            targetItemId,
            position
          });
          setItems(newItems);
        }} onItemClick={item => {
          console.log("Clicked:", item);
        }} />
        </List>
      </Stack>
    </Box>;
}`,...B.parameters?.docs?.source}}};P.parameters={...P.parameters,docs:{...P.parameters?.docs,source:{originalSource:`() => {
  const STORAGE_KEY = "treeview-expanded-items-lazy";
  const allItems: TreeViewItem[] = [{
    id: "1",
    parentId: null,
    childrenCount: 2
  }, {
    id: "2",
    parentId: null,
    childrenCount: 1
  }, {
    id: "3",
    parentId: null,
    childrenCount: 0
  }, {
    id: "1-1",
    parentId: "1",
    childrenCount: 2
  }, {
    id: "1-2",
    parentId: "1",
    childrenCount: 0
  }, {
    id: "1-1-1",
    parentId: "1-1",
    childrenCount: 0
  }, {
    id: "1-1-2",
    parentId: "1-1",
    childrenCount: 0
  }, {
    id: "2-1",
    parentId: "2",
    childrenCount: 0
  }, {
    id: "4",
    parentId: null,
    childrenCount: 1
  }, {
    id: "4-1",
    parentId: "4",
    childrenCount: 0
  }];
  const loadFromStorage = (): TreeViewItemId[] => {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        return JSON.parse(stored);
      }
    } catch (error) {
      console.error("Failed to load from localStorage:", error);
    }
    return ["1", "1-1"];
  };
  const [expandedItemIds, setExpandedItemIds] = useState<TreeViewItemId[]>(loadFromStorage);
  const handleExpandedItemsChange = (itemIds: TreeViewItemId[]) => {
    setExpandedItemIds(itemIds);
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(itemIds));
      console.log("Saved to localStorage:", itemIds);
    } catch (error) {
      console.error("Failed to save to localStorage:", error);
    }
  };
  const fetchItems = async (parentIds: (TreeViewItemId | null)[]): Promise<TreeViewItem[]> => {
    await new Promise(resolve => setTimeout(resolve, 500));
    const result: TreeViewItem[] = [];
    parentIds.forEach(parentId => {
      const children = allItems.filter(item => item.parentId === parentId);
      result.push(...children);
    });
    parentIds.forEach(parentId => {
      if (parentId !== null) {
        const item = allItems.find(item => item.id === parentId);
        if (item && !result.find(r => r.id === item.id)) {
          result.push(item);
        }
      }
    });
    console.log("API Request - parentIds:", parentIds);
    console.log("API Response - items:", result);
    return result;
  };
  return <Box sx={{
    width: 400,
    p: 2
  }}>
      <Stack spacing={2}>
        <Typography variant="h6">
          TreeView - Controlled Mode with Lazy Loading
        </Typography>
        <Typography variant="caption" color="text.secondary">
          Combines controlled expanded state with lazy loading. Expanded state
          is persisted to localStorage and restored on page reload.
        </Typography>
        <Box>
          <Typography variant="caption" color="text.secondary">
            Currently expanded:{" "}
          </Typography>
          {expandedItemIds.length > 0 ? <Box sx={{
          display: "flex",
          gap: 0.5,
          flexWrap: "wrap",
          mt: 0.5
        }}>
              {expandedItemIds.map(id => <Chip key={id} label={id} size="small" />)}
            </Box> : <Typography variant="caption" color="text.secondary">
              None
            </Typography>}
        </Box>
        <TreeView dataSource={{
        fetchItems,
        onItemsLoaded: items => {
          console.log("Items loaded:", items);
        },
        onLoadError: (error, parentIds) => {
          console.error("Load error:", error, "for parentIds:", parentIds);
        }
      }} expandedItemIds={expandedItemIds} onExpandedItemsChange={handleExpandedItemsChange} getItemLabel={item => \`Item \${item.id}\`} getItemIcon={item => item.childrenCount > 0 ? <FolderIcon fontSize="small" /> : <DescriptionIcon fontSize="small" />} onItemClick={item => {
        console.log("Clicked:", item);
      }} />
      </Stack>
    </Box>;
}`,...P.parameters?.docs?.source}}};$.parameters={...$.parameters,docs:{...$.parameters?.docs,source:{originalSource:`() => {
  const [hasItems, setHasItems] = useState(false);
  const emptyItems: TreeViewItem[] = [];
  const itemsWithData: TreeViewItem[] = [{
    id: "1",
    parentId: null,
    childrenCount: 2
  }, {
    id: "2",
    parentId: null,
    childrenCount: 1
  }, {
    id: "1-1",
    parentId: "1",
    childrenCount: 0
  }, {
    id: "1-2",
    parentId: "1",
    childrenCount: 0
  }, {
    id: "2-1",
    parentId: "2",
    childrenCount: 0
  }];
  const emptyStateComponent = <Box sx={{
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    py: 4,
    px: 2,
    textAlign: "center"
  }}>
      <FolderOpenIcon sx={{
      fontSize: 48,
      color: "text.secondary",
      mb: 2,
      opacity: 0.5
    }} />
      <Typography variant="h6" color="text.secondary" gutterBottom>
        No items found
      </Typography>
      <Typography variant="body2" color="text.secondary">
        The tree view is empty. Add items to get started.
      </Typography>
    </Box>;
  return <Box sx={{
    width: 400,
    p: 2
  }}>
      <Stack spacing={2}>
        <Typography variant="h6">TreeView with Empty State</Typography>
        <Typography variant="caption" color="text.secondary">
          This example demonstrates the emptyState prop. Toggle the button below
          to show/hide items.
        </Typography>
        <Box>
          <Chip label={hasItems ? "Hide Items" : "Show Items"} onClick={() => setHasItems(!hasItems)} clickable color={hasItems ? "primary" : "default"} />
        </Box>
        <TreeView items={hasItems ? itemsWithData : emptyItems} emptyState={emptyStateComponent} getItemLabel={item => \`Item \${item.id}\`} getItemIcon={item => item.childrenCount > 0 ? <FolderIcon fontSize="small" /> : <DescriptionIcon fontSize="small" />} onItemClick={item => {
        console.log("Clicked:", item);
      }} />
      </Stack>
    </Box>;
}`,...$.parameters?.docs?.source}}};F.parameters={...F.parameters,docs:{...F.parameters?.docs,source:{originalSource:`() => {
  const [key, setKey] = useState(0);
  const allItems: TreeViewItem[] = [{
    id: "1",
    parentId: null,
    childrenCount: 2
  }, {
    id: "2",
    parentId: null,
    childrenCount: 1
  }, {
    id: "3",
    parentId: null,
    childrenCount: 0
  }, {
    id: "1-1",
    parentId: "1",
    childrenCount: 2
  }, {
    id: "1-2",
    parentId: "1",
    childrenCount: 0
  }, {
    id: "1-1-1",
    parentId: "1-1",
    childrenCount: 0
  }, {
    id: "1-1-2",
    parentId: "1-1",
    childrenCount: 0
  }, {
    id: "2-1",
    parentId: "2",
    childrenCount: 0
  }, {
    id: "4",
    parentId: null,
    childrenCount: 1
  }, {
    id: "4-1",
    parentId: "4",
    childrenCount: 0
  }];
  const fetchItems = async (parentIds: (TreeViewItemId | null)[]): Promise<TreeViewItem[]> => {
    await new Promise(resolve => setTimeout(resolve, 1500));
    const result: TreeViewItem[] = [];
    parentIds.forEach(parentId => {
      const children = allItems.filter(item => item.parentId === parentId);
      result.push(...children);
    });
    parentIds.forEach(parentId => {
      if (parentId !== null) {
        const item = allItems.find(item => item.id === parentId);
        if (item && !result.find(r => r.id === item.id)) {
          result.push(item);
        }
      }
    });
    console.log("API Request - parentIds:", parentIds);
    console.log("API Response - items:", result);
    return result;
  };
  const handleReload = () => {
    setKey(prev => prev + 1);
  };
  return <Box sx={{
    width: 400,
    p: 2
  }}>
      <Stack spacing={2}>
        <Typography variant="h6">TreeView with Loader Demo</Typography>
        <Typography variant="caption" color="text.secondary">
          Click the "Reload" button to see the skeleton loader during initial
          loading.
        </Typography>
        <Box>
          <Button variant="contained" onClick={handleReload}>
            Reload
          </Button>
        </Box>
        <TreeView key={key} dataSource={{
        fetchItems,
        onItemsLoaded: items => {
          console.log("Items loaded:", items);
        },
        onLoadError: (error, parentIds) => {
          console.error("Load error:", error, "for parentIds:", parentIds);
        }
      }} getItemLabel={item => \`Item \${item.id}\`} getItemIcon={item => item.childrenCount > 0 ? <FolderIcon fontSize="small" /> : <DescriptionIcon fontSize="small" />} onItemClick={item => {
        console.log("Clicked:", item);
      }} />
      </Stack>
    </Box>;
}`,...F.parameters?.docs?.source}}};H.parameters={...H.parameters,docs:{...H.parameters?.docs,source:{originalSource:`() => {
  const treeViewRef = useRef<TreeViewRef>(null);
  const [expandedItemIds, setExpandedItemIds] = useState<TreeViewItemId[]>(["1"]);
  const [deletedItemIds, setDeletedItemIds] = useState<Set<TreeViewItemId>>(new Set());
  const [createdItems, setCreatedItems] = useState<TreeViewItem[]>([]);
  const [nextItemId, setNextItemId] = useState(100);
  const [pendingRefresh, setPendingRefresh] = useState<{
    parentIds: (TreeViewItemId | null)[];
  } | null>(null);
  const initialItems: TreeViewItem[] = [{
    id: "1",
    parentId: null,
    childrenCount: 2
  }, {
    id: "2",
    parentId: null,
    childrenCount: 1
  }, {
    id: "3",
    parentId: null,
    childrenCount: 0
  }, {
    id: "1-1",
    parentId: "1",
    childrenCount: 2
  }, {
    id: "1-2",
    parentId: "1",
    childrenCount: 0
  }, {
    id: "1-1-1",
    parentId: "1-1",
    childrenCount: 0
  }, {
    id: "1-1-2",
    parentId: "1-1",
    childrenCount: 0
  }, {
    id: "2-1",
    parentId: "2",
    childrenCount: 0
  }];
  const allItems = useMemo(() => {
    const deletedSet = deletedItemIds;
    const filtered = initialItems.filter(item => {
      if (deletedSet.has(item.id)) {
        return false;
      }
      let currentParentId: TreeViewItemId | null = item.parentId;
      while (currentParentId !== null) {
        if (deletedSet.has(currentParentId)) {
          return false;
        }
        const parent = initialItems.find(i => i.id === currentParentId);
        currentParentId = parent?.parentId ?? null;
      }
      return true;
    });
    const combined = [...filtered, ...createdItems];
    return combined.map(item => {
      const actualChildrenCount = combined.filter(child => child.parentId === item.id).length;
      return {
        ...item,
        childrenCount: actualChildrenCount
      };
    });
  }, [deletedItemIds, createdItems]);
  const fetchItems = useCallback(async (parentIds: (TreeViewItemId | null)[]): Promise<TreeViewItem[]> => {
    await new Promise(resolve => setTimeout(resolve, 500));
    const result: TreeViewItem[] = [];
    const resultIds = new Set<TreeViewItemId>();
    parentIds.forEach(parentId => {
      const children = allItems.filter(item => item.parentId === parentId);
      children.forEach(child => {
        if (!resultIds.has(child.id)) {
          result.push(child);
          resultIds.add(child.id);
        }
      });
    });
    parentIds.forEach(parentId => {
      if (parentId !== null) {
        const item = allItems.find(item => item.id === parentId);
        if (item && !resultIds.has(item.id)) {
          result.push(item);
          resultIds.add(item.id);
        }
      } else {
        const rootItems = allItems.filter(item => item.parentId === null);
        rootItems.forEach(item => {
          if (!resultIds.has(item.id)) {
            result.push(item);
            resultIds.add(item.id);
          }
        });
      }
    });
    console.log("API Request - parentIds:", parentIds);
    console.log("API Response - items:", result);
    return result;
  }, [allItems]);
  useEffect(() => {
    if (pendingRefresh) {
      const timeoutId = setTimeout(() => {
        treeViewRef.current?.refresh(pendingRefresh.parentIds);
        setPendingRefresh(null);
      }, 0);
      return () => clearTimeout(timeoutId);
    }
  }, [pendingRefresh, deletedItemIds]);
  const handleRefreshAll = () => {
    console.log("Refreshing all expanded items");
    treeViewRef.current?.refresh();
  };
  const handleRefreshRoot = () => {
    console.log("Refreshing root level");
    treeViewRef.current?.refresh([null]);
  };
  const handleRefreshItem1 = () => {
    console.log("Refreshing item '1' and its children");
    treeViewRef.current?.refresh(["1"]);
  };
  return <Box sx={{
    width: 400,
    p: 2
  }}>
      <Stack spacing={2}>
        <Typography variant="h6">TreeView with Refresh API</Typography>
        <Typography variant="caption" color="text.secondary">
          This example demonstrates the refresh functionality. After performing
          operations like create, update, or delete, you can refresh specific
          branches or all expanded items.
        </Typography>
        <Box sx={{
        display: "flex",
        gap: 1,
        flexWrap: "wrap"
      }}>
          <Button variant="outlined" size="small" onClick={handleRefreshAll}>
            Refresh All Expanded
          </Button>
          <Button variant="outlined" size="small" onClick={handleRefreshRoot}>
            Refresh Root
          </Button>
          <Button variant="outlined" size="small" onClick={handleRefreshItem1}>
            Refresh Item "1"
          </Button>
          <Button variant="outlined" size="small" color="success" onClick={() => {
          const newId = \`new-root-\${nextItemId}\`;
          console.log("Simulated create root item:", newId);
          const newItem: TreeViewItem = {
            id: newId,
            parentId: null,
            childrenCount: 0
          };
          setCreatedItems(prev => [...prev, newItem]);
          setNextItemId(prev => prev + 1);
          setPendingRefresh({
            parentIds: [null]
          });
        }}>
            Create Root Item
          </Button>
        </Box>
        <Box>
          <Typography variant="caption" color="text.secondary">
            Currently expanded:{" "}
          </Typography>
          {expandedItemIds.length > 0 ? <Box sx={{
          display: "flex",
          gap: 0.5,
          flexWrap: "wrap",
          mt: 0.5
        }}>
              {expandedItemIds.map(id => <Chip key={id} label={id} size="small" />)}
            </Box> : <Typography variant="caption" color="text.secondary">
              None
            </Typography>}
        </Box>
        <TreeView ref={treeViewRef} dataSource={{
        fetchItems,
        onItemsLoaded: items => {
          console.log("Items loaded:", items);
        },
        onLoadError: (error, parentIds) => {
          console.error("Load error:", error, "for parentIds:", parentIds);
        }
      }} expandedItemIds={expandedItemIds} onExpandedItemsChange={setExpandedItemIds} getItemLabel={item => \`Item \${item.id}\`} getItemIcon={item => item.childrenCount > 0 ? <FolderIcon fontSize="small" /> : <DescriptionIcon fontSize="small" />} getItemActions={(item): TreeViewAction[] => [{
        label: "Create child",
        icon: <AddIcon fontSize="small" />,
        onClick: () => {
          const newId = \`new-\${nextItemId}\`;
          console.log("Simulated create of:", newId, "under parent:", item.id);
          const newItem: TreeViewItem = {
            id: newId,
            parentId: item.id,
            childrenCount: 0
          };
          setCreatedItems(prev => [...prev, newItem]);
          setNextItemId(prev => prev + 1);
          if (!expandedItemIds.includes(item.id)) {
            setExpandedItemIds(prev => [...prev, item.id]);
          }
          const parentIds = [item.id];
          setPendingRefresh({
            parentIds
          });
        }
      }, {
        label: "Delete (simulated)",
        icon: <DeleteIcon fontSize="small" />,
        sx: {
          color: "error.main"
        },
        onClick: () => {
          console.log("Simulated delete of:", item.id);
          const parentIds = item.parentId !== null ? [item.parentId] : [null];
          setCreatedItems(prev => prev.filter(i => i.id !== item.id));
          setDeletedItemIds(prev => {
            const next = new Set(prev);
            next.add(item.id);
            return next;
          });
          setPendingRefresh({
            parentIds
          });
        }
      }]} onItemClick={item => {
        console.log("Clicked:", item);
      }} />
      </Stack>
    </Box>;
}`,...H.parameters?.docs?.source}}};W.parameters={...W.parameters,docs:{...W.parameters?.docs,source:{originalSource:`() => {
  const [shouldFail, setShouldFail] = useState(false);
  const [errorCount, setErrorCount] = useState(0);
  const allItems: TreeViewItem[] = [{
    id: "1",
    parentId: null,
    childrenCount: 2
  }, {
    id: "2",
    parentId: null,
    childrenCount: 1
  }, {
    id: "3",
    parentId: null,
    childrenCount: 0
  }, {
    id: "1-1",
    parentId: "1",
    childrenCount: 0
  }, {
    id: "1-2",
    parentId: "1",
    childrenCount: 0
  }, {
    id: "2-1",
    parentId: "2",
    childrenCount: 0
  }];
  const fetchItems = async (parentIds: (TreeViewItemId | null)[]): Promise<TreeViewItem[]> => {
    await new Promise(resolve => setTimeout(resolve, 500));
    if (shouldFail) {
      setErrorCount(prev => prev + 1);
      throw new Error("Failed to load items. Please try again.");
    }
    const result: TreeViewItem[] = [];
    parentIds.forEach(parentId => {
      const children = allItems.filter(item => item.parentId === parentId);
      result.push(...children);
    });
    parentIds.forEach(parentId => {
      if (parentId !== null) {
        const item = allItems.find(item => item.id === parentId);
        if (item && !result.find(r => r.id === item.id)) {
          result.push(item);
        }
      } else {
        const rootItems = allItems.filter(item => item.parentId === null);
        rootItems.forEach(item => {
          if (!result.find(r => r.id === item.id)) {
            result.push(item);
          }
        });
      }
    });
    return result;
  };
  return <Box sx={{
    width: 400,
    p: 2
  }}>
      <Stack spacing={2}>
        <Typography variant="h6">TreeView with Error Handling</Typography>
        <Typography variant="caption" color="text.secondary">
          This example demonstrates error handling in lazy loading mode. Toggle
          the error state to see how errors are handled.
        </Typography>
        <Box sx={{
        display: "flex",
        gap: 1,
        alignItems: "center"
      }}>
          <Button variant={shouldFail ? "contained" : "outlined"} color={shouldFail ? "error" : "primary"} size="small" onClick={() => setShouldFail(!shouldFail)}>
            {shouldFail ? "Disable Errors" : "Simulate Errors"}
          </Button>
          {errorCount > 0 && <Chip label={\`Errors: \${errorCount}\`} color="error" size="small" />}
        </Box>
        <TreeView dataSource={{
        fetchItems,
        onLoadError: (error, parentIds) => {
          console.error("Load error:", error, "for parentIds:", parentIds);
        }
      }} getItemLabel={item => \`Item \${item.id}\`} getItemIcon={item => item.childrenCount > 0 ? <FolderIcon fontSize="small" /> : <DescriptionIcon fontSize="small" />} onItemClick={item => {
        console.log("Clicked:", item);
      }} />
      </Stack>
    </Box>;
}`,...W.parameters?.docs?.source}}};U.parameters={...U.parameters,docs:{...U.parameters?.docs,source:{originalSource:`() => {
  const generateItems = (): TreeViewItem[] => {
    const items: TreeViewItem[] = [];
    const itemsPerLevel = 5;
    const levels = 4;
    for (let i = 1; i <= itemsPerLevel; i++) {
      items.push({
        id: \`root-\${i}\`,
        parentId: null,
        childrenCount: itemsPerLevel
      });
    }
    for (let level = 1; level <= levels; level++) {
      const parentPrefix = level === 1 ? "root" : \`level-\${level - 1}\`;
      const currentPrefix = \`level-\${level}\`;
      for (let parentNum = 1; parentNum <= itemsPerLevel; parentNum++) {
        const parentId = level === 1 ? \`root-\${parentNum}\` : \`\${parentPrefix}-\${parentNum}\`;
        for (let childNum = 1; childNum <= itemsPerLevel; childNum++) {
          const hasChildren = level < levels;
          items.push({
            id: \`\${currentPrefix}-\${parentNum}-\${childNum}\`,
            parentId,
            childrenCount: hasChildren ? itemsPerLevel : 0
          });
        }
      }
    }
    return items;
  };
  const allItems = useMemo(() => generateItems(), []);
  const fetchItems = useCallback(async (parentIds: (TreeViewItemId | null)[]): Promise<TreeViewItem[]> => {
    await new Promise(resolve => setTimeout(resolve, 300));
    const result: TreeViewItem[] = [];
    parentIds.forEach(parentId => {
      const children = allItems.filter(item => item.parentId === parentId);
      result.push(...children);
    });
    parentIds.forEach(parentId => {
      if (parentId !== null) {
        const item = allItems.find(item => item.id === parentId);
        if (item && !result.find(r => r.id === item.id)) {
          result.push(item);
        }
      } else {
        const rootItems = allItems.filter(item => item.parentId === null);
        rootItems.forEach(item => {
          if (!result.find(r => r.id === item.id)) {
            result.push(item);
          }
        });
      }
    });
    return result;
  }, [allItems]);
  return <Box sx={{
    width: 400,
    p: 2
  }}>
      <Stack spacing={2}>
        <Typography variant="h6">TreeView with Large Dataset</Typography>
        <Typography variant="caption" color="text.secondary">
          This example demonstrates performance with a large dataset (
          {allItems.length} items). Items are loaded lazily as you expand
          folders.
        </Typography>
        <TreeView dataSource={{
        fetchItems,
        debounceMs: 100
      }} getItemLabel={item => \`Item \${item.id}\`} getItemIcon={item => item.childrenCount > 0 ? <FolderIcon fontSize="small" /> : <DescriptionIcon fontSize="small" />} onItemClick={item => {
        console.log("Clicked:", item);
      }} />
      </Stack>
    </Box>;
}`,...U.parameters?.docs?.source}}};N.parameters={...N.parameters,docs:{...N.parameters?.docs,source:{originalSource:`() => {
  const [isExpanded, setIsExpanded] = useState(true);
  return <Box sx={{
    width: 400,
    p: 2
  }}>
      <Stack spacing={2}>
        <Typography variant="h6">TreeViewHeader with TreeView</Typography>
        <List>
          <TreeViewHeader icon={<FolderIcon />} title="My Folders" collapseButton={{
          isExpanded,
          onToggle: () => setIsExpanded(!isExpanded)
        }} action={{
          icon: <AddIcon />,
          tooltip: "Create new folder",
          onClick: () => console.log("Create clicked")
        }} onClick={() => console.log("Header clicked")} />
          {isExpanded && <TreeView items={mockItems} getItemLabel={item => \`Item \${item.id}\`} getItemIcon={item => item.childrenCount > 0 ? <FolderIcon fontSize="small" /> : <DescriptionIcon fontSize="small" />} onItemClick={item => {
          console.log("Clicked:", item);
        }} rootOffset={1} />}
        </List>
      </Stack>
    </Box>;
}`,...N.parameters?.docs?.source}}};M.parameters={...M.parameters,docs:{...M.parameters?.docs,source:{originalSource:`() => {
  const items = [{
    id: "folder-1",
    parentId: null,
    childrenCount: 2,
    name: "Team A"
  }, {
    id: "folder-2",
    parentId: null,
    childrenCount: 1,
    name: "Team B"
  }, {
    id: "folder-3",
    parentId: null,
    childrenCount: 0,
    name: "Team C"
  }, {
    id: "folder-1-1",
    parentId: "folder-1",
    childrenCount: 0,
    name: "Subteam 1"
  }, {
    id: "folder-1-2",
    parentId: "folder-1",
    childrenCount: 0,
    name: "Subteam 2"
  }, {
    id: "folder-2-1",
    parentId: "folder-2",
    childrenCount: 0,
    name: "Subteam 3"
  }];
  const [droppedUsers, setDroppedUsers] = useState<Record<string, typeof mockUsers>>({});
  const [headerDroppedUsers, setHeaderDroppedUsers] = useState<typeof mockUsers>([]);
  const [activeId, setActiveId] = useState<string | null>(null);
  const [isExpanded, setIsExpanded] = useState(true);
  const activeUser = activeId ? mockUsers.find(u => u.id === activeId) : null;
  const handleExternalDrop = useCallback((event: {
    type: string;
    data: any[];
  }, targetItem: TreeViewItem, position: "before" | "after" | "inside") => {
    console.log("External drop:", {
      type: event.type,
      data: event.data,
      targetItem: targetItem.id,
      position
    });
    const folderId = String(targetItem.id);
    const users = event.data as typeof mockUsers;
    setDroppedUsers(prev => ({
      ...prev,
      [folderId]: [...(prev[folderId] || []), ...users]
    }));
    alert(\`Dropped \${users.length} user(s) into "\${targetItem.name || targetItem.id}"\`);
  }, []);
  const handleHeaderDrop = useCallback((event: {
    type: string;
    data: unknown[];
  }) => {
    const users = event.data as typeof mockUsers;
    setHeaderDroppedUsers(prev => [...prev, ...users]);
    alert(\`Dropped \${users.length} user(s) into root header\`);
  }, []);
  const canAcceptExternalDrop = useCallback((dropType: string) => {
    if (dropType !== "Users") return false;
    return true;
  }, []);
  const handleDragStart = useCallback((event: DragStartEvent) => {
    setActiveId(String(event.active.id));
  }, []);
  const handleDragEnd = useCallback(() => {
    setActiveId(null);
  }, []);
  const HeaderDropMonitor = () => {
    useDndMonitor({
      onDragOver: ({
        over,
        active
      }) => {
        if (!over || !active?.data?.current?.type) return;
        const droppableId = String(over.id);
        if (droppableId.startsWith("tree-header-")) {
          const dropType = active.data.current.type;
          const canAccept = canAcceptExternalDrop(dropType) ?? true;
          if (canAccept) {
            console.log("Dragging over header:", droppableId);
          }
        }
      },
      onDragEnd: ({
        over,
        active
      }) => {
        if (!over || !active?.data?.current?.type) return;
        const droppableId = String(over.id);
        if (droppableId.startsWith("tree-header-")) {
          const dropType = active.data.current.type;
          const dropData = active.data.current.data || [];
          const canAccept = canAcceptExternalDrop(dropType) ?? true;
          if (canAccept) {
            handleHeaderDrop({
              type: dropType,
              data: Array.isArray(dropData) ? dropData : [dropData]
            });
          }
        }
      }
    });
    return null;
  };
  return <DndContext onDragStart={handleDragStart} onDragEnd={handleDragEnd}>
      <HeaderDropMonitor />
      <Box sx={{
      width: "100%",
      p: 2
    }}>
        <Stack spacing={3} direction="row" sx={{
        height: 600
      }}>
          <Paper sx={{
          width: 300,
          p: 2,
          overflow: "auto",
          position: "relative"
        }}>
            <Typography variant="h6" gutterBottom>
              Users (Drag to folders)
            </Typography>
            <Typography variant="caption" color="text.secondary" sx={{
            mb: 2,
            display: "block"
          }}>
              Drag users from this list and drop them into the header or folders
              in the tree
            </Typography>
            <List>
              {mockUsers.map(user => <DraggableUserItem key={user.id} user={user} />)}
            </List>
          </Paper>

          <Paper sx={{
          flex: 1,
          p: 2,
          overflow: "auto"
        }}>
            <Typography variant="h6" gutterBottom>
              Folders with Header (Drop users here)
            </Typography>
            <Typography variant="caption" color="text.secondary" sx={{
            mb: 2,
            display: "block"
          }}>
              Drag users from the left panel and drop them into the header or
              folders. Items will highlight when you drag over them.
            </Typography>
            <List>
              <TreeViewHeader icon={<FolderIcon />} title={\`Root Folder\${headerDroppedUsers.length > 0 ? \` (\${headerDroppedUsers.length} users)\` : ""}\`} dropId="root" enableExternalDrops={true} canAcceptExternalDrop={canAcceptExternalDrop} collapseButton={{
              isExpanded,
              onToggle: () => setIsExpanded(!isExpanded)
            }} action={{
              icon: <AddIcon />,
              tooltip: "Create new folder",
              onClick: () => console.log("Create clicked")
            }} onClick={() => console.log("Header clicked")} />
              {isExpanded && <TreeView items={items} rootOffset={1} enableExternalDrops={true} onExternalDrop={handleExternalDrop} canAcceptExternalDrop={canAcceptExternalDrop} getItemLabel={item => {
              const name = (item as any).name || \`Item \${item.id}\`;
              const userCount = droppedUsers[String(item.id)]?.length || 0;
              return userCount > 0 ? \`\${name} (\${userCount} users)\` : name;
            }} getItemIcon={item => item.childrenCount > 0 ? <FolderIcon fontSize="small" /> : <FolderOpenIcon fontSize="small" />} onItemClick={item => {
              const users = droppedUsers[String(item.id)];
              if (users && users.length > 0) {
                console.log(\`Users in \${item.id}:\`, users);
                alert(\`Users in this folder:\\n\${users.map(u => \`- \${u.name}\`).join("\\n")}\`);
              } else {
                console.log("Clicked:", item);
              }
            }} />}
            </List>
          </Paper>
        </Stack>
      </Box>
      {createPortal(<DragOverlay style={{
      zIndex: 1500
    }}>
          {activeUser ? <Paper sx={{
        width: 280,
        p: 1.5,
        border: "1px solid",
        borderColor: "divider",
        borderRadius: 1,
        bgcolor: "background.paper",
        boxShadow: 3,
        display: "flex",
        alignItems: "center"
      }}>
              <DragIndicatorIcon sx={{
          mr: 1,
          color: "text.secondary"
        }} />
              <Avatar sx={{
          width: 32,
          height: 32,
          mr: 1,
          bgcolor: "primary.main"
        }}>
                <PersonIcon fontSize="small" />
              </Avatar>
              <Box>
                <Typography variant="body2" fontWeight="medium">
                  {activeUser.name}
                </Typography>
                <Typography variant="caption" color="text.secondary">
                  {activeUser.email}
                </Typography>
              </Box>
            </Paper> : null}
        </DragOverlay>, document.body)}
    </DndContext>;
}`,...M.parameters?.docs?.source}}};const Nt=["Basic","WithActions","WithSelection","WithDragAndDrop","WithDragAndDropToHeader","ControlledModeWithLazyLoading","WithEmptyState","WithLoaderDemo","WithRefreshAPI","WithErrorHandling","WithLargeDataset","HeaderWithTreeView","WithHeaderAndExternalDrops"];export{V as Basic,P as ControlledModeWithLazyLoading,N as HeaderWithTreeView,L as WithActions,A as WithDragAndDrop,B as WithDragAndDropToHeader,$ as WithEmptyState,W as WithErrorHandling,M as WithHeaderAndExternalDrops,U as WithLargeDataset,F as WithLoaderDemo,H as WithRefreshAPI,R as WithSelection,Nt as __namedExportsOrder,Ut as default};
